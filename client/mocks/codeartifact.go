// Code generated by MockGen. DO NOT EDIT.
// Source: codeartifact.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	codeartifact "github.com/aws/aws-sdk-go-v2/service/codeartifact"
	gomock "github.com/golang/mock/gomock"
)

// MockCodeartifactClient is a mock of CodeartifactClient interface.
type MockCodeartifactClient struct {
	ctrl     *gomock.Controller
	recorder *MockCodeartifactClientMockRecorder
}

// MockCodeartifactClientMockRecorder is the mock recorder for MockCodeartifactClient.
type MockCodeartifactClientMockRecorder struct {
	mock *MockCodeartifactClient
}

// NewMockCodeartifactClient creates a new mock instance.
func NewMockCodeartifactClient(ctrl *gomock.Controller) *MockCodeartifactClient {
	mock := &MockCodeartifactClient{ctrl: ctrl}
	mock.recorder = &MockCodeartifactClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCodeartifactClient) EXPECT() *MockCodeartifactClientMockRecorder {
	return m.recorder
}

// DescribeDomain mocks base method.
func (m *MockCodeartifactClient) DescribeDomain(arg0 context.Context, arg1 *codeartifact.DescribeDomainInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.DescribeDomainOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeDomain", varargs...)
	ret0, _ := ret[0].(*codeartifact.DescribeDomainOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeDomain indicates an expected call of DescribeDomain.
func (mr *MockCodeartifactClientMockRecorder) DescribeDomain(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeDomain", reflect.TypeOf((*MockCodeartifactClient)(nil).DescribeDomain), varargs...)
}

// DescribePackage mocks base method.
func (m *MockCodeartifactClient) DescribePackage(arg0 context.Context, arg1 *codeartifact.DescribePackageInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.DescribePackageOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribePackage", varargs...)
	ret0, _ := ret[0].(*codeartifact.DescribePackageOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribePackage indicates an expected call of DescribePackage.
func (mr *MockCodeartifactClientMockRecorder) DescribePackage(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribePackage", reflect.TypeOf((*MockCodeartifactClient)(nil).DescribePackage), varargs...)
}

// DescribePackageGroup mocks base method.
func (m *MockCodeartifactClient) DescribePackageGroup(arg0 context.Context, arg1 *codeartifact.DescribePackageGroupInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.DescribePackageGroupOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribePackageGroup", varargs...)
	ret0, _ := ret[0].(*codeartifact.DescribePackageGroupOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribePackageGroup indicates an expected call of DescribePackageGroup.
func (mr *MockCodeartifactClientMockRecorder) DescribePackageGroup(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribePackageGroup", reflect.TypeOf((*MockCodeartifactClient)(nil).DescribePackageGroup), varargs...)
}

// DescribePackageVersion mocks base method.
func (m *MockCodeartifactClient) DescribePackageVersion(arg0 context.Context, arg1 *codeartifact.DescribePackageVersionInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.DescribePackageVersionOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribePackageVersion", varargs...)
	ret0, _ := ret[0].(*codeartifact.DescribePackageVersionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribePackageVersion indicates an expected call of DescribePackageVersion.
func (mr *MockCodeartifactClientMockRecorder) DescribePackageVersion(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribePackageVersion", reflect.TypeOf((*MockCodeartifactClient)(nil).DescribePackageVersion), varargs...)
}

// DescribeRepository mocks base method.
func (m *MockCodeartifactClient) DescribeRepository(arg0 context.Context, arg1 *codeartifact.DescribeRepositoryInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.DescribeRepositoryOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeRepository", varargs...)
	ret0, _ := ret[0].(*codeartifact.DescribeRepositoryOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeRepository indicates an expected call of DescribeRepository.
func (mr *MockCodeartifactClientMockRecorder) DescribeRepository(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeRepository", reflect.TypeOf((*MockCodeartifactClient)(nil).DescribeRepository), varargs...)
}

// GetAssociatedPackageGroup mocks base method.
func (m *MockCodeartifactClient) GetAssociatedPackageGroup(arg0 context.Context, arg1 *codeartifact.GetAssociatedPackageGroupInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetAssociatedPackageGroupOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAssociatedPackageGroup", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetAssociatedPackageGroupOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAssociatedPackageGroup indicates an expected call of GetAssociatedPackageGroup.
func (mr *MockCodeartifactClientMockRecorder) GetAssociatedPackageGroup(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAssociatedPackageGroup", reflect.TypeOf((*MockCodeartifactClient)(nil).GetAssociatedPackageGroup), varargs...)
}

// GetAuthorizationToken mocks base method.
func (m *MockCodeartifactClient) GetAuthorizationToken(arg0 context.Context, arg1 *codeartifact.GetAuthorizationTokenInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetAuthorizationTokenOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAuthorizationToken", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetAuthorizationTokenOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuthorizationToken indicates an expected call of GetAuthorizationToken.
func (mr *MockCodeartifactClientMockRecorder) GetAuthorizationToken(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuthorizationToken", reflect.TypeOf((*MockCodeartifactClient)(nil).GetAuthorizationToken), varargs...)
}

// GetDomainPermissionsPolicy mocks base method.
func (m *MockCodeartifactClient) GetDomainPermissionsPolicy(arg0 context.Context, arg1 *codeartifact.GetDomainPermissionsPolicyInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetDomainPermissionsPolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDomainPermissionsPolicy", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetDomainPermissionsPolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDomainPermissionsPolicy indicates an expected call of GetDomainPermissionsPolicy.
func (mr *MockCodeartifactClientMockRecorder) GetDomainPermissionsPolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDomainPermissionsPolicy", reflect.TypeOf((*MockCodeartifactClient)(nil).GetDomainPermissionsPolicy), varargs...)
}

// GetPackageVersionAsset mocks base method.
func (m *MockCodeartifactClient) GetPackageVersionAsset(arg0 context.Context, arg1 *codeartifact.GetPackageVersionAssetInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetPackageVersionAssetOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPackageVersionAsset", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetPackageVersionAssetOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPackageVersionAsset indicates an expected call of GetPackageVersionAsset.
func (mr *MockCodeartifactClientMockRecorder) GetPackageVersionAsset(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPackageVersionAsset", reflect.TypeOf((*MockCodeartifactClient)(nil).GetPackageVersionAsset), varargs...)
}

// GetPackageVersionReadme mocks base method.
func (m *MockCodeartifactClient) GetPackageVersionReadme(arg0 context.Context, arg1 *codeartifact.GetPackageVersionReadmeInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetPackageVersionReadmeOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPackageVersionReadme", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetPackageVersionReadmeOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPackageVersionReadme indicates an expected call of GetPackageVersionReadme.
func (mr *MockCodeartifactClientMockRecorder) GetPackageVersionReadme(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPackageVersionReadme", reflect.TypeOf((*MockCodeartifactClient)(nil).GetPackageVersionReadme), varargs...)
}

// GetRepositoryEndpoint mocks base method.
func (m *MockCodeartifactClient) GetRepositoryEndpoint(arg0 context.Context, arg1 *codeartifact.GetRepositoryEndpointInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetRepositoryEndpointOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRepositoryEndpoint", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetRepositoryEndpointOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepositoryEndpoint indicates an expected call of GetRepositoryEndpoint.
func (mr *MockCodeartifactClientMockRecorder) GetRepositoryEndpoint(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepositoryEndpoint", reflect.TypeOf((*MockCodeartifactClient)(nil).GetRepositoryEndpoint), varargs...)
}

// GetRepositoryPermissionsPolicy mocks base method.
func (m *MockCodeartifactClient) GetRepositoryPermissionsPolicy(arg0 context.Context, arg1 *codeartifact.GetRepositoryPermissionsPolicyInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.GetRepositoryPermissionsPolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRepositoryPermissionsPolicy", varargs...)
	ret0, _ := ret[0].(*codeartifact.GetRepositoryPermissionsPolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRepositoryPermissionsPolicy indicates an expected call of GetRepositoryPermissionsPolicy.
func (mr *MockCodeartifactClientMockRecorder) GetRepositoryPermissionsPolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepositoryPermissionsPolicy", reflect.TypeOf((*MockCodeartifactClient)(nil).GetRepositoryPermissionsPolicy), varargs...)
}

// ListAllowedRepositoriesForGroup mocks base method.
func (m *MockCodeartifactClient) ListAllowedRepositoriesForGroup(arg0 context.Context, arg1 *codeartifact.ListAllowedRepositoriesForGroupInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListAllowedRepositoriesForGroupOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAllowedRepositoriesForGroup", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListAllowedRepositoriesForGroupOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAllowedRepositoriesForGroup indicates an expected call of ListAllowedRepositoriesForGroup.
func (mr *MockCodeartifactClientMockRecorder) ListAllowedRepositoriesForGroup(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAllowedRepositoriesForGroup", reflect.TypeOf((*MockCodeartifactClient)(nil).ListAllowedRepositoriesForGroup), varargs...)
}

// ListAssociatedPackages mocks base method.
func (m *MockCodeartifactClient) ListAssociatedPackages(arg0 context.Context, arg1 *codeartifact.ListAssociatedPackagesInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListAssociatedPackagesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAssociatedPackages", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListAssociatedPackagesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAssociatedPackages indicates an expected call of ListAssociatedPackages.
func (mr *MockCodeartifactClientMockRecorder) ListAssociatedPackages(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAssociatedPackages", reflect.TypeOf((*MockCodeartifactClient)(nil).ListAssociatedPackages), varargs...)
}

// ListDomains mocks base method.
func (m *MockCodeartifactClient) ListDomains(arg0 context.Context, arg1 *codeartifact.ListDomainsInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListDomainsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDomains", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListDomainsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDomains indicates an expected call of ListDomains.
func (mr *MockCodeartifactClientMockRecorder) ListDomains(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDomains", reflect.TypeOf((*MockCodeartifactClient)(nil).ListDomains), varargs...)
}

// ListPackageGroups mocks base method.
func (m *MockCodeartifactClient) ListPackageGroups(arg0 context.Context, arg1 *codeartifact.ListPackageGroupsInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListPackageGroupsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackageGroups", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListPackageGroupsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPackageGroups indicates an expected call of ListPackageGroups.
func (mr *MockCodeartifactClientMockRecorder) ListPackageGroups(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackageGroups", reflect.TypeOf((*MockCodeartifactClient)(nil).ListPackageGroups), varargs...)
}

// ListPackageVersionAssets mocks base method.
func (m *MockCodeartifactClient) ListPackageVersionAssets(arg0 context.Context, arg1 *codeartifact.ListPackageVersionAssetsInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionAssetsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackageVersionAssets", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListPackageVersionAssetsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPackageVersionAssets indicates an expected call of ListPackageVersionAssets.
func (mr *MockCodeartifactClientMockRecorder) ListPackageVersionAssets(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackageVersionAssets", reflect.TypeOf((*MockCodeartifactClient)(nil).ListPackageVersionAssets), varargs...)
}

// ListPackageVersionDependencies mocks base method.
func (m *MockCodeartifactClient) ListPackageVersionDependencies(arg0 context.Context, arg1 *codeartifact.ListPackageVersionDependenciesInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionDependenciesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackageVersionDependencies", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListPackageVersionDependenciesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPackageVersionDependencies indicates an expected call of ListPackageVersionDependencies.
func (mr *MockCodeartifactClientMockRecorder) ListPackageVersionDependencies(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackageVersionDependencies", reflect.TypeOf((*MockCodeartifactClient)(nil).ListPackageVersionDependencies), varargs...)
}

// ListPackageVersions mocks base method.
func (m *MockCodeartifactClient) ListPackageVersions(arg0 context.Context, arg1 *codeartifact.ListPackageVersionsInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListPackageVersionsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackageVersions", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListPackageVersionsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPackageVersions indicates an expected call of ListPackageVersions.
func (mr *MockCodeartifactClientMockRecorder) ListPackageVersions(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackageVersions", reflect.TypeOf((*MockCodeartifactClient)(nil).ListPackageVersions), varargs...)
}

// ListPackages mocks base method.
func (m *MockCodeartifactClient) ListPackages(arg0 context.Context, arg1 *codeartifact.ListPackagesInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListPackagesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackages", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListPackagesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPackages indicates an expected call of ListPackages.
func (mr *MockCodeartifactClientMockRecorder) ListPackages(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackages", reflect.TypeOf((*MockCodeartifactClient)(nil).ListPackages), varargs...)
}

// ListRepositories mocks base method.
func (m *MockCodeartifactClient) ListRepositories(arg0 context.Context, arg1 *codeartifact.ListRepositoriesInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListRepositoriesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRepositories", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListRepositoriesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRepositories indicates an expected call of ListRepositories.
func (mr *MockCodeartifactClientMockRecorder) ListRepositories(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRepositories", reflect.TypeOf((*MockCodeartifactClient)(nil).ListRepositories), varargs...)
}

// ListRepositoriesInDomain mocks base method.
func (m *MockCodeartifactClient) ListRepositoriesInDomain(arg0 context.Context, arg1 *codeartifact.ListRepositoriesInDomainInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListRepositoriesInDomainOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRepositoriesInDomain", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListRepositoriesInDomainOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRepositoriesInDomain indicates an expected call of ListRepositoriesInDomain.
func (mr *MockCodeartifactClientMockRecorder) ListRepositoriesInDomain(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRepositoriesInDomain", reflect.TypeOf((*MockCodeartifactClient)(nil).ListRepositoriesInDomain), varargs...)
}

// ListSubPackageGroups mocks base method.
func (m *MockCodeartifactClient) ListSubPackageGroups(arg0 context.Context, arg1 *codeartifact.ListSubPackageGroupsInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListSubPackageGroupsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSubPackageGroups", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListSubPackageGroupsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSubPackageGroups indicates an expected call of ListSubPackageGroups.
func (mr *MockCodeartifactClientMockRecorder) ListSubPackageGroups(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSubPackageGroups", reflect.TypeOf((*MockCodeartifactClient)(nil).ListSubPackageGroups), varargs...)
}

// ListTagsForResource mocks base method.
func (m *MockCodeartifactClient) ListTagsForResource(arg0 context.Context, arg1 *codeartifact.ListTagsForResourceInput, arg2 ...func(*codeartifact.Options)) (*codeartifact.ListTagsForResourceOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListTagsForResource", varargs...)
	ret0, _ := ret[0].(*codeartifact.ListTagsForResourceOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTagsForResource indicates an expected call of ListTagsForResource.
func (mr *MockCodeartifactClientMockRecorder) ListTagsForResource(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTagsForResource", reflect.TypeOf((*MockCodeartifactClient)(nil).ListTagsForResource), varargs...)
}
